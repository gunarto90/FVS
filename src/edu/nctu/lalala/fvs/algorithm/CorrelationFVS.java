package edu.nctu.lalala.fvs.algorithm;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import edu.nctu.lalala.enums.ThresholdType;
import edu.nctu.lalala.fvs.CorrelationMatrix;
import edu.nctu.lalala.fvs.FV;
import edu.nctu.lalala.fvs.interfaces.IFVS;
import edu.nctu.lalala.util.FVSHelper;
import weka.core.Instance;
import weka.core.Instances;

public class CorrelationFVS implements IFVS {

	class XYPair {
		public int x, y;

		public XYPair(int x, int y) {
			this.x = x;
			this.y = y;
		}

		@Override
		public boolean equals(Object obj) {
			XYPair other = (XYPair) obj;
			return this.x == other.x && this.y == other.y;
		}
	}

	Instances inst;
	Instances output;
	Map<FV, Collection<FV>> fv_list;
	Map<FV, Collection<FV>> filtered_fv;
	ThresholdType thr_alg;
	double topk;
	double corrThreshold;
	Double[][] CM;
	List<Double> corrValues;

	public CorrelationFVS(ThresholdType thr_alg) {
		this.thr_alg = thr_alg;
		this.filtered_fv = new HashMap<FV, Collection<FV>>();
	}

	@Override
	public void input(Instances inst, Instances output, Object... params) {
		this.inst = inst;
		this.output = output;
		this.fv_list = FVSHelper.getInstance().extractValuesFromData(inst);
		this.topk = (Double) params[0];
		preprocessing(inst);
	}

	private void preprocessing(Instances inst) {
		CorrelationMatrix cm = FVSHelper.getInstance().generateCorrelationMatrix(inst);
		this.CM = cm.getCM();
		this.corrValues = cm.getCorrValues();
		Double[] temp = new Double[corrValues.size()];
		temp = corrValues.toArray(temp);
		this.corrThreshold = FVSHelper.getInstance().thresholdSelection(0, temp, this.thr_alg);
		FVSHelper.getInstance().generateEntropy(fv_list, inst.numInstances());
	}

	/**
	 * Correlation FVS 1. Create several list for each correlated features 2.
	 * For each correlated feature, put all FV into list and do selection based
	 * on top-k percent 3. When doing selection, check on every list (because
	 * every correlated feature would have different list and non-correlated
	 * feature, would have a separate list). For example: there is 5 features A,
	 * B, C, D, and E. Then, correlated pairs are: A with B, A with C, A with D,
	 * B with D, and C with D. Then we would have several list for them: AB
	 * list, AC list, AD list, BD list, CD list, and E list. (E is a
	 * non-correlated feature, thus have a separate list by itself). 4. Evaluate
	 * the parameters: top-k percents and threshold selection (for correlation).
	 */
	@Override
	public void applyFVS() {
		this.filtered_fv = new HashMap<FV, Collection<FV>>();
		List<List<FV>> correlatedFV = generateCorrelatedFV(this.inst);
		for (List<FV> list : correlatedFV) {
			List<FV> subset = selectSubsetTopKPercent(topk, list);
			for (FV fv : subset) {
				filtered_fv.put(fv, null);
			}
		}
	}

	@Override
	public Instances output() {
		Instances output = FVSHelper.getInstance().transformInstances(inst, this.output, filtered_fv);
		return output;
	}

	private List<FV> selectSubsetTopKPercent(double topk, List<FV> input) {
		// Lookup these fv from fvlist (query the entropy values)
		List<FV> list = new ArrayList<>();
		for (FV fv : input) {
			Collection<FV> col = fv_list.get(fv);
			if (col==null || col.isEmpty()) {
				continue;
			}
			Iterator<FV> iter = col.iterator();
			if (iter.hasNext()) {
				list.add(iter.next());
			}
		}
		List<FV> result = new ArrayList<>();
		Collections.sort(list);
		// Prevent out of size
		int limit = (int) Math.min((int) (list.size() * topk) + 1, list.size() - 1);
		limit = (int) Math.max(limit, 0); // Prevent negative
		list = list.subList(0, limit);
		// Put all of remaining FVs into result
		for (FV fv : list) {
			if (!result.contains(fv))
				result.add(fv);
		}
		return result;
	}

	/**
	 * Correlated feature-values are generated by observing two factors:
	 * correlation in the feature and appearance in the instances. If two
	 * features are correlated and the values in the respective features are
	 * correlated, then these values are correlated each other.
	 * 
	 * @return
	 */
	private List<List<FV>> generateCorrelatedFV(Instances inst) {
		// Create fxf list for each correlated features
		List<List<FV>> correlatedFV = new ArrayList<>();
		// Lookup correlation matrix to create list of correlated features
		Map<Integer, Integer> featureUsed = new HashMap<>();
		List<XYPair> correlatedFeatures = new ArrayList<>();
		for (int i = 0; i < CM.length; i++) {
			for (int j = i + 1; j < CM.length; j++) {
				if (CM[i][j] >= corrThreshold) {
					featureUsed.put(i, 1);
					featureUsed.put(j, 1);
					correlatedFeatures.add(new XYPair(i, j));
				}
			}
		}
		// Iterate over all instances to create correlated lists
		List<FV> uncorrelatedFVs = new ArrayList<>();
		for (int x = 0; x < inst.numInstances(); x++) {
			Instance in = inst.instance(x);
			// Lookup correlation matrix
			for (XYPair p : correlatedFeatures) {
				FV fv1 = new FV(p.x, in.stringValue(p.x), in.classValue());
				FV fv2 = new FV(p.y, in.stringValue(p.y), in.classValue());
				boolean found = false;
				for (int i = 0; i < correlatedFV.size(); i++) {
					if (found)
						break;
					List<FV> list = correlatedFV.get(i);
					// Add missing correlated fv
					if (list.contains(fv1)) {
						list.add(fv2);
						found = true;
					} else if (list.contains(fv2)) {
						list.add(fv1);
						found = true;
					}
				}
				if (!found) {
					List<FV> list = new ArrayList<>();
					list.add(fv1);
					list.add(fv2);
					correlatedFV.add(list);
				}
			}
			// Uncorrelated features
			for (int i = 0; i < CM.length; i++) {
				if (featureUsed.get(i) == null) {
					FV fv = new FV(i, in.value(i), in.classValue());
					if (!uncorrelatedFVs.contains(fv))
						uncorrelatedFVs.add(fv);
				}
			}
		}
		correlatedFV.add(uncorrelatedFVs);
		//System.out.println("Correlated FV length: " + correlatedFV.size());
		return correlatedFV;
	}
}
